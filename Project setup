छान — मी तुझ्या दिलेल्या JSON फील्ड्सनुसार backend code फुलपणे update करून इथे देता आहे. मी JSON मधल्या request_data.inputs मधल्या keys (उदा. _1a_DOB, _1b_Product, _1c_Gender, इत्यादी) च्या नावे लक्षात घेतली आणि Java DTOs मध्ये सोपे, स्पष्ट field names वापरले (ज्यांना frontend सहजपणे map करता येईल). तसेच एक wrapper request class बनवलं आहे ज्याने संपूर्ण incoming JSON receive होईल, नंतर त्यातून एक flattened CalculationRequest बनवून CoherentService कडे पाठवले जाईल.

तुम्ही हे फाईल्स थेट copy–paste करू शकता.


---

1) pom.xml

(जर आधीच नसेल तर; lombok आणि webflux आहे)

<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>com.eapp</groupId>
  <artifactId>eapp-backend</artifactId>
  <version>1.0.0</version>

  <properties>
    <java.version>17</java.version>
    <spring.boot.version>3.1.6</spring.boot.version>
  </properties>

  <dependencyManagement>
    <dependencies>
      <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-dependencies</artifactId>
        <version>${spring.boot.version}</version>
        <type>pom</type>
        <scope>import</scope>
      </dependency>
    </dependencies>
  </dependencyManagement>

  <dependencies>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-webflux</artifactId>
    </dependency>

    <dependency>
      <groupId>com.fasterxml.jackson.core</groupId>
      <artifactId>jackson-databind</artifactId>
    </dependency>

    <dependency>
      <groupId>org.projectlombok</groupId>
      <artifactId>lombok</artifactId>
      <version>1.18.28</version>
      <scope>provided</scope>
    </dependency>

    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-validation</artifactId>
    </dependency>

    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-test</artifactId>
      <scope>test</scope>
    </dependency>
  </dependencies>

  <build>
    <plugins>
      <plugin>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-maven-plugin</artifactId>
      </plugin>
    </plugins>
  </build>
</project>


---

2) EappBackendApplication.java

package com.eapp;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class EappBackendApplication {
    public static void main(String[] args) {
        SpringApplication.run(EappBackendApplication.class, args);
    }
}


---

3) DTOs for incoming JSON (wrapper)

dto/wrapper/RootRequest.java

package com.eapp.dto.wrapper;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

@Data
public class RootRequest {
    @JsonProperty("request_data")
    private RequestData requestData;

    @JsonProperty("request_meta")
    private RequestMeta requestMeta;

    @JsonProperty("requested_output")
    private Object requestedOutput;

    @JsonProperty("service_category")
    private Object serviceCategory;
}

dto/wrapper/RequestData.java

package com.eapp.dto.wrapper;

import lombok.Data;

@Data
public class RequestData {
    private Inputs inputs;
}

dto/wrapper/Inputs.java

package com.eapp.dto.wrapper;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

/**
 * Fields map to the incoming keys. Use @JsonProperty for exact JSON key names.
 */
@Data
public class Inputs {
    @JsonProperty("_1a_DOB")
    private String dob;

    @JsonProperty("_1b_Product")
    private String product;

    @JsonProperty("_1c_Gender")
    private String gender;

    @JsonProperty("_1d_Face_Amount")
    private Double faceAmount;

    @JsonProperty("_1e_Occupation")
    private Integer occupation;

    @JsonProperty("_1h_Policy_Inception_Date")
    private String policyInceptionDate;

    @JsonProperty("_1i_Smoker")
    private String smoker;

    @JsonProperty("_1j_Pre_Existing_Disease")
    private String preExistingDisease;

    @JsonProperty("_1k_Extra_mortality")
    private Double extraMortality;

    @JsonProperty("_1p_Policy_Term")
    private Integer policyTerm;

    @JsonProperty("_1r_Mandatory_Premium_Period")
    private String mandatoryPremiumPeriod;

    @JsonProperty("_1zb_PAV")
    private Double pav;

    @JsonProperty("_1zc_per_mille_rating_death")
    private Double perMilleRatingDeath;

    @JsonProperty("_1zd_per_mille_rating_TPD")
    private Double perMilleRatingTPD;

    // note: original in your JSON had a small typo `_1ze_per_mille_rating_SCI": 1` — map it correctly:
    @JsonProperty("_1ze_per_mille_rating_SCI")
    private Double perMilleRatingSCI;

    @JsonProperty("_2a_Death_Benefit")
    private String deathBenefit;

    @JsonProperty("_2b_Total_and_Permanent_Disability_TPD")
    private String tpd;

    @JsonProperty("_2c_Accidental_Death_and_Dismemberment_ADD")
    private String add;

    @JsonProperty("_2d_Staged_Critical_Illness_SCI")
    private String sci;

    @JsonProperty("_2e_Hospital_Cash_Benefit_HCB")
    private String hcb;

    @JsonProperty("_3a_Partial_Withdrawl")
    private String partialWithdrawal;

    @JsonProperty("_3b_Partial_Withdrawl_Amount")
    private Double partialWithdrawalAmount;
}

> हे Inputs class JSON मधल्या सर्व keys चा mapping करतो. जर frontend इतर keys पाठवते तर त्यांच्यासाठी new fields add कर.




---

4) Flattened CalculationRequest (service -> coherent payload)

dto/CalculationRequest.java

package com.eapp.dto;

import lombok.Data;

/**
 * Flattened calculation request that CoherentService will send.
 * Modify fields to match actual Coherent API contract if needed.
 */
@Data
public class CalculationRequest {
    private String dob;
    private String product;
    private String gender;
    private Double faceAmount;
    private Integer occupation;
    private String policyInceptionDate;
    private String smoker;
    private String preExistingDisease;
    private Double extraMortality;
    private Integer policyTerm;
    private String mandatoryPremiumPeriod;
    private Double pav;
    private Double perMilleRatingDeath;
    private Double perMilleRatingTPD;
    private Double perMilleRatingSCI;
    private String deathBenefit;
    private String tpd;
    private String add;
    private String sci;
    private String hcb;
    private String partialWithdrawal;
    private Double partialWithdrawalAmount;
}


---

5) CalculationResponse.java

package com.eapp.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CalculationResponse {
    private Double premium;
    private String currency;
    private String message;
}


---

6) CoherentService.java (maps wrapper -> flattened -> calls Coherent)

package com.eapp.service;

import com.eapp.dto.CalculationRequest;
import com.eapp.dto.CalculationResponse;
import com.eapp.dto.wrapper.RootRequest;
import com.eapp.dto.wrapper.Inputs;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Mono;

@Service
@RequiredArgsConstructor
public class CoherentService {

    private final WebClient webClient;

    @Value("${coherent.api.base-url:https://api.coherent.global}")
    private String baseUrl;

    @Value("${coherent.api.calculation-endpoint:/calculation}")
    private String calculationEndpoint;

    @Value("${coherent.api.key:}")
    private String apiKey;

    /**
     * Accepts the raw RootRequest (incoming JSON wrapper), maps it to flattened CalculationRequest,
     * then calls Coherent API and returns CalculationResponse.
     */
    public Mono<CalculationResponse> calculatePremium(RootRequest rootRequest) {
        CalculationRequest req = mapRootToCalculation(rootRequest);

        return webClient.post()
                .uri(baseUrl + calculationEndpoint)
                .contentType(MediaType.APPLICATION_JSON)
                .header("Authorization", apiKey == null || apiKey.isEmpty() ? "" : "Bearer " + apiKey)
                .bodyValue(req)
                .retrieve()
                .bodyToMono(CalculationResponse.class)
                .onErrorResume(ex -> {
                    CalculationResponse err = new CalculationResponse();
                    err.setPremium(0.0);
                    err.setCurrency("INR");
                    err.setMessage("Coherent API error: " + ex.getMessage());
                    return Mono.just(err);
                });
    }

    private CalculationRequest mapRootToCalculation(RootRequest root) {
        CalculationRequest out = new CalculationRequest();
        if (root == null || root.getRequestData() == null || root.getRequestData().getInputs() == null) {
            return out;
        }
        Inputs in = root.getRequestData().getInputs();
        out.setDob(in.getDob());
        out.setProduct(in.getProduct());
        out.setGender(in.getGender());
        out.setFaceAmount(in.getFaceAmount());
        out.setOccupation(in.getOccupation());
        out.setPolicyInceptionDate(in.getPolicyInceptionDate());
        out.setSmoker(in.getSmoker());
        out.setPreExistingDisease(in.getPreExistingDisease());
        out.setExtraMortality(in.getExtraMortality());
        out.setPolicyTerm(in.getPolicyTerm());
        out.setMandatoryPremiumPeriod(in.getMandatoryPremiumPeriod());
        out.setPav(in.getPav());
        out.setPerMilleRatingDeath(in.getPerMilleRatingDeath());
        out.setPerMilleRatingTPD(in.getPerMilleRatingTPD());
        out.setPerMilleRatingSCI(in.getPerMilleRatingSCI());
        out.setDeathBenefit(in.getDeathBenefit());
        out.setTpd(in.getTpd());
        out.setAdd(in.getAdd());
        out.setSci(in.getSci());
        out.setHcb(in.getHcb());
        out.setPartialWithdrawal(in.getPartialWithdrawal());
        out.setPartialWithdrawalAmount(in.getPartialWithdrawalAmount());
        return out;
    }
}


---

7) Controller — CalculationController.java

package com.eapp.controller;

import com.eapp.dto.CalculationResponse;
import com.eapp.dto.wrapper.RootRequest;
import com.eapp.service.CoherentService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Mono;

@RestController
@RequestMapping("/api/v1")
@RequiredArgsConstructor
public class CalculationController {

    private final CoherentService coherentService;

    @PostMapping("/calculate")
    public Mono<ResponseEntity<CalculationResponse>> calculate(@RequestBody RootRequest request) {
        return coherentService.calculatePremium(request)
                .map(ResponseEntity::ok);
    }
}


---

8) WebClientConfig.java

package com.eapp.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.reactive.function.client.WebClient;

@Configuration
public class WebClientConfig {
    @Bean
    public WebClient webClient() {
        return WebClient.builder().build();
    }
}


---

9) application-dev.properties (example)

coherent.api.base-url=https://api.coherent.global
coherent.api.calculation-endpoint=/calculation
coherent.api.key=YOUR_REAL_KEY_HERE


---

Quick notes / assumptions I made

मी incoming JSON च्या keys (जशा _1a_DOB) साठी @JsonProperty वापरली — त्यामुळे frontend ने तसंच JSON पाठवलं तर mapping होईल.

CoherentService मध्ये मी payload म्हणून flattened CalculationRequest पाठवला — तुमच्या Coherent API च्या real contract नुसार हे adjust करावं (किंवा direct request_data पाठवायचं असेल तर bodyValue(rootRequest.getRequestData().getInputs()) असं कर).

काही JSON मध्ये छोटे syntax errors होते (उदा. quotes missing). तुम्ही जे frontend पासून पाठवता ते valid JSON असावे (हा code त्यानुसार काम करेल).

Date fields (dob, policyInceptionDate) मी String ठेवले आहे — नंतर तुम्हाला Date parsing हव्या असतील तर LocalDate मध्ये convert करायला मदत करेन.

per_mille आणि numeric fields Double ठेवल्या आहेत.



---

तू आता हे फाईल्स project मध्ये ठेव — mvn clean package करून run करून बघ.
जर थेट Coherent API चा expected request body schema दिलास, तर मी CoherentService नक्की तशी body तयार करेन (fields map, nested structure इत्यादी) — मग frontend पासून आलेले _1... fields -> Coherent payload एकदम perfect होईल.

मग म्हण — मी आता Coherent चा exact payload mapping करून देऊ का? की आणखी कुठल्या field चे नाव बदलायचे?
